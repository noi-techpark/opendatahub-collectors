// SPDX-FileCopyrightText: 2024 NOI Techpark <digital@noi.bz.it>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

package com.opendatahub.collector.googlesheet;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.UUID;
import java.util.zip.GZIPOutputStream;

import org.apache.camel.ExchangePattern;
import org.apache.camel.LoggingLevel;
import org.apache.camel.builder.AggregationStrategies;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

import com.google.api.services.drive.model.Channel;
import com.google.api.services.sheets.v4.model.GetSpreadsheetByDataFilterRequest;
import com.google.api.services.sheets.v4.model.Spreadsheet;

@Component
public class SheetRoute extends RouteBuilder {
    @Bean("filterReq")
    public GetSpreadsheetByDataFilterRequest filterReq() {
        // includeGridData makes the API return the full spreadsheet.
        // Sadly, this is currently not supported by the component "get" method (although it is on the API side)
        // So we have to (mis)use the "getByDataFilter" method. 
        // Once GoogleSheetsConfiguration supports that parameter, move to a simple 'get'
        GetSpreadsheetByDataFilterRequest reqFilter = new GetSpreadsheetByDataFilterRequest();
        reqFilter.setIncludeGridData(true);
        return reqFilter;
    }

    @Value("${spreadsheet_notificationUrl}")
    String callbackUrl;
    
    // unique random string that identifies our instance of the application when listening to drive notifications
    private final String channelToken = UUID.randomUUID().toString();
    
    @Value("${google_watch_channel_lifetime_hours}")
    // Note that on channel recration, we receive a "sync" message which also triggers a download.
    // In effect, this period is also a baseline polling period regardless of push notifications we get
    int notificationChannelLifetime;

    @Override
    public void configure() throws Exception {

        // Set up google drive file watcher.
        // Since the watcher expires after a time, we have to recreate it in a loop
        //
        // https://developers.google.com/drive/api/guides/push
        from("direct:watchExpirationLoop")
            .process(e -> {
                Channel channel = new Channel();
                channel.setId(UUID.randomUUID().toString());
                channel.setType("web_hook");
                channel.setAddress(callbackUrl);
                // Renew channel every 24h.
                channel.setExpiration(System.currentTimeMillis() + 1000 * 60 * 60 * notificationChannelLifetime);
                channel.setToken(channelToken);
                // set the channel for watch setup as header.
                // https://camel.apache.org/components/4.0.x/google-drive-component.html#_api_drive-files_method_watch
                e.getMessage().setHeader("CamelGoogleDrive.channel", channel);
            })
        .to("google-drive:DRIVE_FILES/watch?fileId={{spreadsheetId}}")
            .convertBodyTo(Channel.class)
            .process(e -> {
                Channel channel = e.getMessage().getBody(Channel.class);
                log.info("File watcher set up with ID = {}, token = {} and expiration = {}", channel.getId(), channel.getToken(), channel.getExpiration());
                long delay = channel.getExpiration() - System.currentTimeMillis() - 1000;
                log.debug("Recreating file watch in {} ms", delay);
                e.getMessage().setHeader("delay", delay);
            })
            .delay().expression(header("delay"))
            .to("direct:watchExpirationLoop");

        // Start up the watcher loop
        from("timer:startWatchExpirationLoop?delay=5000&repeatCount=1")
        .to("direct:watchExpirationLoop");
        
        from("rest:post:{{trigger.path}}")
            .routeId("trigger-route")
            // Only look at notifications generated by our own channel
            .filter(e -> channelToken.equals(e.getMessage().getHeader("X-Goog-Channel-Token")))
            .log(LoggingLevel.INFO, "Sync triggered")
            // Aggregate messages into a single one over a time period.
            // When someone is editing a spreadsheet, there could be a lot of triggers within a short time.
            // We way, we only update the spreadsheet every n seconds at most
            .aggregate(AggregationStrategies.useLatest())
                .simple("true") // aggregation expression. We aggregate all messages by using a static value
                .completionInterval("{{maxUpdateFrequency:20000}}")
        .to("seda:updateSpreadsheet");
        
        // The part where we actually collect data
        from("seda:updateSpreadsheet?exchangePattern=InOnly")
            .routeId("update-route")
            .removeHeaders("*")
            .setExchangePattern(ExchangePattern.InOnly)
        .log(LoggingLevel.INFO, "Spreadsheet update event received. Downloading spreadsheet")
        .to("google-sheets://spreadsheets/getByDataFilter"
            + "?spreadsheetId={{spreadsheetId}}"
            + "&getSpreadsheetByDataFilterRequest=#bean:filterReq")
            .process(e -> {
                var sheet = (Spreadsheet) e.getMessage().getBody();
                // convert to JSON string
                String json = sheet.toString();

                // gzip it
                ByteArrayOutputStream zipped = new ByteArrayOutputStream();
                GZIPOutputStream zos = new GZIPOutputStream(zipped);
                zos.write(json.getBytes(StandardCharsets.UTF_8));
                zos.close();

                // base64 encode the gzipped json
                String base64ZippedJson = Base64.getUrlEncoder().encodeToString(zipped.toByteArray());
                e.getMessage().setBody(base64ZippedJson);
            })
        .to("direct:mq") ;
    }
}
